---
title: Next.js App Router
---

import { Steps, FileTree } from 'nextra/components'

# Next.js App Router Guide

A complete guide to integrating `notion-to-jsx` with Next.js App Router.

## Project structure

<FileTree>
  <FileTree.Folder name="lib" defaultOpen>
    <FileTree.File name="notion.ts" />
  </FileTree.Folder>
  <FileTree.Folder name="app" defaultOpen>
    <FileTree.File name="layout.tsx" />
    <FileTree.Folder name="posts" defaultOpen>
      <FileTree.File name="page.tsx" />
      <FileTree.Folder name="[slug]" defaultOpen>
        <FileTree.File name="page.tsx" />
        <FileTree.File name="PostRenderer.tsx" />
      </FileTree.Folder>
    </FileTree.Folder>
  </FileTree.Folder>
</FileTree>

<Steps>

### Notion client (server-only)

```ts copy filename="lib/notion.ts"
import { Client } from 'notion-to-utils';

export const notionClient = new Client({
  auth: process.env.NOTION_TOKEN,
});

export const databaseId = process.env.NOTION_DATABASE_ID;
```

### Root layout with CSS

```tsx copy filename="app/layout.tsx"
import 'notion-to-jsx/dist/index.css';
import 'prismjs/themes/prism-tomorrow.css';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

### Post list page (Server Component)

```tsx copy filename="app/posts/page.tsx"
import Link from 'next/link';
import { notionClient, databaseId } from '@/lib/notion';
import { extractValuesFromProperties } from 'notion-to-utils';

export default async function PostsPage() {
  const response = await notionClient.dataSources.query({
    data_source_id: databaseId!,
  });

  return (
    <ul>
      {response.results.map((page: any) => {
        const values = extractValuesFromProperties(page.properties);
        return (
          <li key={page.id}>
            <Link href={`/posts/${values.Slug}`}>
              {values.Name}
            </Link>
          </li>
        );
      })}
    </ul>
  );
}
```

### Post detail page (Server Component)

```tsx copy filename="app/posts/[slug]/page.tsx"
import { notionClient, databaseId } from '@/lib/notion';
import PostRenderer from './PostRenderer';

export default async function PostPage({ params }: { params: Promise<{ slug: string }> }) {
  const { slug } = await params;

  // Look up the page ID by Slug
  const { results } = await notionClient.dataSources.query({
    data_source_id: databaseId!,
    filter: {
      property: 'Slug',
      rich_text: { equals: slug },
    },
  });
  const pageId = results[0].id;

  const [blocks, properties] = await Promise.all([
    notionClient.getPageBlocks(pageId),
    notionClient.getPageProperties(pageId),
  ]);

  return (
    <PostRenderer
      blocks={blocks}
      title={(properties?.['Name'] as string) || ''}
      cover={(properties?.['coverUrl'] as string) || ''}
    />
  );
}
```

### Renderer wrapper (Client Component)

```tsx copy filename="app/posts/[slug]/PostRenderer.tsx"
'use client';

import { Renderer } from 'notion-to-jsx';
import type { NotionBlock } from 'notion-to-jsx';

interface Props {
  blocks: NotionBlock[];
  title?: string;
  cover?: string;
}

export default function PostRenderer({ blocks, title, cover }: Props) {
  return (
    <Renderer
      blocks={blocks}
      title={title}
      cover={cover}
      showToc
      tocStyle={{ top: '20%' }}
    />
  );
}
```

</Steps>

## Why server + client split?

- **Server Component**: Fetches data from Notion API using server-only environment variables
- **Client Component**: `Renderer` needs client-side features (scroll, interactive ToC)

> [!TIP]
> This pattern ensures API tokens stay on the server while the UI remains interactive.
